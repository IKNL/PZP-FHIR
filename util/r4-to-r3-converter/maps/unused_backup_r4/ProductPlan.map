map "http://hl7.org/fhir/StructureMap/ProductPlan4to3" = "R4 to R3 Conversion for ProductPlan"

uses "http://hl7.org/fhir/StructureDefinition/ProductPlan" alias ProductPlan as source
uses "http://hl7.org/fhir/3.0/StructureDefinition/ProductPlan" alias ProductPlanR3 as target

imports "http://hl7.org/fhir/StructureMap/*4to3"

group ProductPlan(source src : ProductPlanR3, target tgt : ProductPlan) extends DomainResource <<type+>> {
  src.identifier as vs -> tgt.identifier as vt then Identifier(vs, vt);
  src.status as vs -> tgt.status as vt then code(vs, vt);
  src.type as vs -> tgt.type as vt then string(vs, vt);
  src.name as vs -> tgt.name as vt then string(vs, vt);
  src.alias as vs -> tgt.alias as vt then string(vs, vt);
  src.period as vs -> tgt.period as vt then string(vs, vt);
  src.ownedBy as vs -> tgt.ownedBy as vt then string(vs, vt);
  src.administeredBy as vs -> tgt.administeredBy as vt then string(vs, vt);
  src.coverageArea as vs -> tgt.coverageArea as vt then string(vs, vt);
  src.contact as s -> tgt.contact as t then ProductPlanContact(s, t);
  src.endpoint as vs -> tgt.endpoint as vt then string(vs, vt);
  src.network as vs -> tgt.network as vt then string(vs, vt);
  src.coverage as s -> tgt.coverage as t then ProductPlanCoverage(s, t);
  src.plan as s -> tgt.plan as t then ProductPlanPlan(s, t);
}

group ProductPlanContact(source src, target tgt) extends BackboneElement {
  src.purpose as vs -> tgt.purpose as vt then markdown(vs, vt);
  src.name as vs -> tgt.name as vt then string(vs, vt);
  src.telecom as vs -> tgt.telecom as vt then ContactPoint(vs, vt);
  src.address as vs -> tgt.address as vt then Address(vs, vt);
}

group ProductPlanCoverage(source src, target tgt) extends BackboneElement {
  src.type as vs -> tgt.type as vt then string(vs, vt);
  src.network as vs -> tgt.network as vt then string(vs, vt);
  src.benefit as s -> tgt.benefit as t then ProductPlanCoverageBenefit(s, t);
}

group ProductPlanCoverageBenefit(source src, target tgt) extends BackboneElement {
  src.type as vs -> tgt.type as vt then string(vs, vt);
  src.requirement as vs -> tgt.requirement as vt then string(vs, vt);
  src.limit as s -> tgt.limit as t then ProductPlanCoverageBenefitLimit(s, t);
}

group ProductPlanCoverageBenefitLimit(source src, target tgt) extends BackboneElement {
  src.value as vs -> tgt.value as vt then Quantity(vs, vt);
  src.code as vs -> tgt.code as vt then CodeableConcept(vs, vt);
}

group ProductPlanPlan(source src, target tgt) extends BackboneElement {
  src.identifier as vs -> tgt.identifier as vt then Identifier(vs, vt);
  src.type as vs -> tgt.type as vt then string(vs, vt);
  src.coverageArea as vs -> tgt.coverageArea as vt then string(vs, vt);
  src.network as vs -> tgt.network as vt then string(vs, vt);
  src.generalCost as s -> tgt.generalCost as t then ProductPlanPlanGeneralCost(s, t);
  src.specificCost as s -> tgt.specificCost as t then ProductPlanPlanSpecificCost(s, t);
}

group ProductPlanPlanGeneralCost(source src, target tgt) extends BackboneElement {
  src.type as vs -> tgt.type as vt then string(vs, vt);
  src.groupSize as vs -> tgt.groupSize as vt then string(vs, vt);
  src.cost as vs -> tgt.cost as vt then string(vs, vt);
  src.comment as vs -> tgt.comment as vt then string(vs, vt);
}

group ProductPlanPlanSpecificCost(source src, target tgt) extends BackboneElement {
  src.category as vs -> tgt.category as vt then CodeableConcept(vs, vt);
  src.benefit as s -> tgt.benefit as t then ProductPlanPlanSpecificCostBenefit(s, t);
}

group ProductPlanPlanSpecificCostBenefit(source src, target tgt) extends BackboneElement {
  src.type as vs -> tgt.type as vt then string(vs, vt);
  src.cost as s -> tgt.cost as t then ProductPlanPlanSpecificCostBenefitCost(s, t);
}

group ProductPlanPlanSpecificCostBenefitCost(source src, target tgt) extends BackboneElement {
  src.type as vs -> tgt.type as vt then string(vs, vt);
  src.applicability as vs -> tgt.applicability as vt then string(vs, vt);
  src.qualifiers as vs -> tgt.qualifiers as vt then string(vs, vt);
  src.value as vs -> tgt.value as vt then Quantity(vs, vt);
}

